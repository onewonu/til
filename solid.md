# Introduction
_소프트웨어 설계에서 유지보수성과 확장성을 높이기 위해 설계 시 준수해야 할 기본 원칙._
> SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.   
> '클래스'라는 단어를 사용했다고 해서 SOLID 원칙이 객체 지향 소프트웨어에만 적용된다는 뜻은 아니다. 여기서 클래스는 단순히 함수와 데이터의 집합을 가리킨다.  
> ...  
> SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 있다.
> - 변경에 유연하다.
> - 이해하기 쉽다.
> - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
>
> '중간 수준'이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다.   
> 즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용 되는 소프트웨어 구조를 정의하는 데 도움을 준다.

개발 과정에서 비용 효율성과 유지보수성을 충분히 고려하지 않으면 시스템은 쉽게 복잡해지고, 각 요소 간 결합도가 높아져 작은 변경 사항도 시스템 전체에 영향을 미치게 된다.  
이는 예기치 않은 오류를 발생시키고, 유지보수의 어려움을 가중시키며, 시간이 지남에 따라 수정 비용과 시간이 크게 증가할 수 있다.

SOLID 원칙은 소프트웨어 설계에서 클래스 배치와 결합 방식을 정의해 더 효율적인 시스템 아키텍처를 구축하고, 변경 사항 발생 시 그 범위가 최소화되도록 하여 장기적으로 효율적인 개발과 유지보수를 가능하게 한다.

소프트웨어 구조는 변화에 유연하게 대응할 수 있도록 설계되며, 다양한 시스템에서 재사용 가능한 견고한 컴포넌트를 만드는 것을 목표로 한다.

# Single Responsibility Principle - SRP
_하나의 클래스는 하나의 책임만 가져야 하며, 변경하는 이유는 오직 하나여야 한다._
### 1. 단일책임과 변경의 이유
> 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙이다. 이 원칙은 커다란 함수를 작은 함수들로 리펙터링하는 더 저수준에서 사용된다. 하지만 이 원칙은 SOLID 원칙이 아니며, SRP도 아니다.  
> ...  
> SRP가 말하는 '변경의 이유'란 바로 이들 사용자와 이해관계자를 가리킨다.  
> ...  
> 해당 변경을 요청하는 한 명 이상의 사람들을 가리킨다. 이러한 집단을 **액터(actor)** 라고 부르겠다. 이제 SRP의 최종 버전은 아래와 같다.
>
>> _하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임을 져야 한다._
>
>그럼 모듈(module)이란 또 무슨 뜻인가? 가장 단순한 정의는 바로 소스파일이다.  
>...  
>일부 언어와 개발 환경에서는 코드를 소스파일에 저장하지 않는다. 이러한 경우 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.

하나의 클래스나 모듈이 다양한 사용자나 액터의 요구에 대응하지 않도록 설계해야 하며, 이는 각 액터가 클래스에 제시하는 요구사항을 독립적으로 처리할 수 있도록 도와준다.   
만약 하나의 클래스가 여러 액터의 요구를 처리한다면, 그 클래스는 다양한 변경에 노출되기 때문에 SRP 를 위반하게 된다.

단순히 기능을 작은 함수로 분리하는 것을 넘어서, 소프트웨어 설계에서 각 모듈이 하나의 명확한 역할만을 담당하도록 책임을 분리하는 것이다. 이를 통해, 변경이 필요할 때 그 영향이 최소화되며, 유지보수와 확장성이 향상된다.  

SRP 의 본질적인 의미는 함수 리펙터링과 달리 **모듈 또는 클래스 수준** 에서의 책임 분리의 목적에 있다. 모듈이 변경되는 이유를 명확히 하고, 변경의 요구사항을 제시하는 **액터(actor)** 를 한정하는 것이 핵심.  

하나의 클래스나 모듈이 여러 액터의 요구를 수용하지 않도록 하여, 소프트웨어의 변경 가능성을 줄이고 안정성을 높이는 중요한 원칙이다.

### 2. 응집도
> '응집된(cohesive)'이라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.  

응집도가 높다는 것은 모듈이 하나의 **액터(actor)** 에 대해 책임을 진다는 것을 의미한다. 필요할 때 관련된 부분만을 집중적으로 수정할 수 있어 유지보수성의 증대를 기대할 수 있다.

### 3. 위반 케이스
#### 3.1 우발적 중복

<img src="/image/p.68%20SRP-Problem01.png" width="800" height="300" title="" alt="p.68 SRP-Problem01"/>

> ...서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다.

1. 개발자가 각기 다른 기능 세가지 메서드를 하나의 클래스 안에 배치하여, 액터가 서로 결합된 상황.
2. 이 클래스에는 하나의 알고리즘을 공유하며, 서로 다른 액터를 책임지는 메서드가 a(), b()가 존재한다.
3. 업무를 할당 받은 개발자는 b() 메서드를 수정해야 하지만, 알고리즘이 공유 되고 있는 a() 메서드에 대해 알지 못해 a() 메서드에도 수정 사항이 반영되어 문제가 발생.

#### 3.2 병합
> 최근 도구는 굉장히 뛰어나지만, 어떤 도구도 병합이 발생하는 모든 경우를 해결할 수 없다. 결국 병합에는 항상 위험이 뒤따르게 된다.
1. 개발자가 a() 메서드의 수정과 동시에 DBA 가 해당 테이블 스키마를 수정하기 위해 두 개발자가 하나의 클래스를 체크아웃 받은 후 변경사항을 적용.
2. 변경 사항이 충돌해 병합이 발생.

### 4. 위반에 대한 솔루션: 데이터 및 메서드 분리와 Facade Pattern
_데이터만 가지고 있는 클래스 공유_
- 각 클래스는 자신의 메서드에 필요한 요소만 코드만 포함하고 서로 존재를 모른다.
- 분리된 클래스를 인스턴스화 하고 추적 해야하는 단점이 발생.

<img src="/image/p.70%20SRP-Solution01.png" width="450" height="300" alt="p.70 SRP-Solution01"/>
<br><br>

_Facade Pattern_
- 간소화된 인터페이스를 제공한다.
- 객체를 생성하며, 클라이언트의 요청을 적절한 서브시스템의 메서드로 전달하는 역할.

<img src="/image/p.70%20SRP-Solution02.png" width="450" height="300" alt="p.70 SRP-Solution02"/>
<br><br>

_중요도에 따른 Facade Pattern_
- 기존 클래스와 직접적인 연관이 있는 메서드를 제외하고 개별 클래스로 분리 후, 기존 클래스를 퍼사드로 사용.

<img src="/image/p.70%20SRP-Solution03.png" width="450" height="300" alt="p.70 SRP-Solution03"/>

# OCP
_소프트웨어의 구성 요소는 확장에 열려 있어야 하지만, 변경에 닫혀 있어야 한다._
### 1. 확장과 변경
> 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.
> 소프트웨서 아키텍처를 공부하는 가장 근본적인 이유가 바로 이때문이다.   
> ...  
> 소프트웨어 설계를 공부하기 시작한 지 얼마 안된 사람들 대다수는 OCP를 클래스와 모듈을 설계할 때 도움되는 원칙이라고 알고 있다. 하지만 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미를 가진다.

_확장에 열려 있어야 한다._  

소프트웨어 구성 요소는 새로운 기능이나 요구 사항을 수용할 수 있도록, 기존의 코드를 그대로 두고 추가 요소나 기능을 넣을 수 있는 유연한 구조로 설계되어야 한다. 이를 통해 소프트웨어는 변경 없이 점진적으로 발전하고 새로운 요구사항을 충족할 수 있다.

추상화와 인터페이스의 개념을 활용하는 것이 중요하며, 새로운 기능은 기존 클래스나 모듈을 상속하거나 구현하는 방식으로 추가되어야 한다. 이러한 방식은 코드의 재사용성을 높이는 동시에 시스템을 확장할 때 발생하는 복잡성을 줄여준다.

확장이 용이한 구조는 장기적으로 유지보수 비용을 줄이고, 요구 사항 변화에 신속히 대응할 수 있는 시스템을 구축할 수 있다.

<br>

_변경에 닫혀 있어야 한다._  

기존의 코드를 수정하지 않고, 확장을 수행할 수 있어야 함을 의미한다.
검증된 기존 코드를 변경함으로써 발생할 수 있는 위험을 최소화함으로써, 확장을 통해 새로운 기능을 추가하면서도 기존의 코드를 안정적으로 유지해 새로운 오류나 문제 발생을 예방할 수 있다.

기존의 코드를 수정하지 않고, 확장을 수행할 수 있어야 함을 의미한다.  

검증된 기존 코드를 변경함으로써 발생할 수 있는 위험을 최소화하고, 이를 통해 새로운 기능을 추가하면서도 기존의 코드를 안정적으로 유지할 수 있다. 이러한 접근은 테스트 범위를 줄이고, 소프트웨어의 신뢰성을 높이는 데 기여한다.

시스템이 복잡해질수록 기존 코드의 변경이 다른 부분에 미치는 영향을 예측하기 어려워지므로, 새로운 기능 추가 시 기존 코드를 건드리지 않도록 하는 것은 필수적이다.
### 2. 의존성 체계화 와 컴포넌트의 계층구조
> 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙 SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙 DIP) 변경량을 최소화할 수 있다.

<img src="/image/p.76%20OCP%20-%20Solution.png" width="1539" height="800" alt="p.76 OCP-Solution"/>

> 여기서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다.   
> ...  
> 또 다른 점은 이중선은 화살표와 오직 한 방향으로 만 교차한다는 사실이다.  
> ...  
> 모든 컴포넌트 관계는 단방향으로 이루어 진다는 뜻이다.  
> ...  
> A 컴포넌트에서 발생한 변경으로부텨 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가  B 컴포넌트에 의존해야 한다. 
> 이 예제의 경우 Presenter에서 발생한 변경으로 부터 Controller를 보호하고자 한다. 그리고 View에서 발생한 변경으로 부터 Presenter를 보호하고자 한다. Interactor는 다른 모든 것에서 발생한 변경으로 부터 보호 하고자 한다.   
> ...  
> Interactor가 이처럼 특별한 위치를 차지해야만 하는가? 그 이유는 바로 Interactor가 업무 규칙을 포함하기 때문이다.  
> ...  
> 보호의 계층구조가 수준(level) 이라는 개념을 바탕으로 어떻게 생성되는지 주목하자.  
> ...  
> OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.  
> ...  
> 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

_단방향 의존성_

소프트웨어 구성 요소 간의 의존성은 단방향으로 이루어져야 한다. 그 이유는 컴포넌트 간 결합도를 낮추고 각 컴포넌트의 변경이 다른 컴포넌트에 미치는 영향을 최소화하기 위함이다.  

단방향 의존성은 **DIP** 와 밀접한 관련이 있으며, 고수준의 정책이나 규칙이 저수준의 구현 세부사항에 의존하지 않도록 설계한다.   
이렇게 설계 된다면, 상위 계층에서 하위 계층으로의 변경이 발생하더라도 상위 계층이 그 영향을 받지 않고 시스템의 유연성을 크게 증가시킨다.

_특정 수준 기반의 계층화_  

시스템 내에서 각 계층은 특정 수준을 기반으로 조직화되어 구성 요소들을 체계적으로 관리하고, 각 계층의 독립성을 보장한다. 이 독립성을 통해 변경 사항이 상위 계층에 미치는 영향을 줄여야 한다.  

계층화된 아키텍처는 계층 간의 의존성 방향을 명확히 함으로써, 변경 사항이 하위 계층에서만 발생하도록 제한하며, 상위 계층이 직접적인 의존성을 가지지 않도록 한다.  

높은 수준의 계층으로 갈수록 보호받는 수준이 높아지며, 이들 계층에는 핵심 비즈니스 로직이나 데이터 관리와 같은 중요한 기능이 포함된다.  
이를 통해 중요한 기능이 안정적으로 유지되며, 외부나 하위 계층의 변화가 있을 때도 재사용성과 유지보수성을 높일 수 있다.




# Ref:
Clean Architecture (p.62~98) - Robert C. Martin