# Introduction
_소프트웨어 설계에서 유지보수성과 확장성을 높이기 위해 설계 시 준수해야 할 기본 원칙._
> SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.   
> '클래스'라는 단어를 사용했다고 해서 SOLID 원칙이 객체 지향 소프트웨어에만 적용된다는 뜻은 아니다. 여기서 클래스는 단순히 함수와 데이터의 집합을 가리킨다.  
> ...  
> SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 있다.
> - 변경에 유연하다.
> - 이해하기 쉽다.
> - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
>
> '중간 수준'이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다.   
> 즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용 되는 소프트웨어 구조를 정의하는 데 도움을 준다.

개발 과정에서 비용 효율성과 유지보수성을 충분히 고려하지 않으면 시스템은 쉽게 복잡해지고, 각 요소 간 결합도가 높아져 작은 변경 사항도 시스템 전체에 영향을 미치게 된다.  
이는 예기치 않은 오류를 발생시키고, 유지보수의 어려움을 가중시키며, 시간이 지남에 따라 수정 비용과 시간이 크게 증가할 수 있다.

SOLID 원칙은 소프트웨어 설계에서 클래스 배치와 결합 방식을 정의해 더 효율적인 시스템 아키텍처를 구축하고, 변경 사항 발생 시 그 범위가 최소화되도록 하여 장기적으로 효율적인 개발과 유지보수를 가능하게 한다.

소프트웨어 구조는 변화에 유연하게 대응할 수 있도록 설계되며, 다양한 시스템에서 재사용 가능한 견고한 컴포넌트를 만드는 것을 목표로 한다.

# Single Responsibility Principle - SRP
_하나의 클래스는 하나의 책임만 가져야 하며, 변경하는 이유는 오직 하나여야 한다._
### 1. 단일책임과 변경의 이유
> 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙이다. 이 원칙은 커다란 함수를 작은 함수들로 리펙터링하는 더 저수준에서 사용된다. 하지만 이 원칙은 SOLID 원칙이 아니며, SRP 도 아니다.  
> ...  
> SRP 가 말하는 '변 경의 이유'란 바로 이들 사용자와 이해관계자를 가리킨다.  
> ...  
> 해당 변경을 요청하는 한 명 이상의 사람들을 가리킨다. 이러한 집단을 **액터(actor)** 라고 부르겠다. 이제 SRP 의 최종 버전은 아래와 같다.
>
>> _하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임을 져야 한다._
>
>그럼 모듈(module)이란 또 무슨 뜻인가? 가장 단순한 정의는 바로 소스파일이다.  
>...  
>일부 언어와 개발 환경에서는 코드를 소스파일에 저장하지 않는다. 이러한 경우 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.

_액터(actor) 에 따른 요구사항_

하나의 클래스나 모듈이 다양한 사용자나 액터의 요구에 대응하지 않도록 설계해야 하며, 이는 각 액터가 클래스에 제시하는 요구사항을 독립적으로 처리할 수 있도록 도와준다.   
만약 하나의 클래스가 여러 액터의 요구를 처리한다면, 그 클래스는 다양한 변경에 노출되기 때문에 SRP 를 위반하게 된다.

단순히 기능을 작은 함수로 분리하는 것을 넘어서, 소프트웨어 설계에서 각 모듈이 하나의 명확한 역할만을 담당하도록 책임을 분리하는 것이다. 이를 통해, 변경이 필요할 때 그 영향이 최소화되며, 유지보수와 확장성이 향상된다.  

<br>

_SRP 의 본질적인 의미_

SRP 의 본질적인 의미는 함수 리펙터링과 달리 **모듈 또는 클래스 수준** 에서의 책임 분리의 목적에 있다. 모듈이 변경되는 이유를 명확히 하고, 변경의 요구사항을 제시하는 **액터(actor)** 를 한정하는 것이 핵심.  

하나의 클래스나 모듈이 여러 액터의 요구를 수용하지 않도록 하여, 소프트웨어의 변경 가능성을 줄이고 안정성을 높이는 중요한 원칙이다.

### 2. 응집도
> '응집된(cohesive)'이라는 단어가 SRP 를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.  

응집도가 높다는 것은 모듈이 하나의 **액터(actor)** 에 대해 책임을 진다는 것을 의미한다. 필요할 때 관련된 부분만을 집중적으로 수정할 수 있어 유지보수성의 증대를 기대할 수 있다.

### 3. 위반 케이스
#### 3.1 우발적 중복

<img src="/image/p.68%20SRP-Problem01.png" width="800" height="300" title="" alt="p.68 SRP-Problem01"/>

> ...
> 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다.
1. 개발자가 각기 다른 기능 세가지 메서드를 하나의 클래스 안에 배치하여, 액터가 서로 결합된 상황.
2. 이 클래스에는 하나의 알고리즘을 공유하며, 서로 다른 액터를 책임지는 메서드가 a(), b()가 존재한다.
3. 업무를 할당 받은 개발자는 b() 메서드를 수정해야 하지만, 알고리즘이 공유 되고 있는 a() 메서드에 대해 알지 못해 a() 메서드에도 수정 사항이 반영되어 문제가 발생.

#### 3.2 병합
> 최근 도구는 굉장히 뛰어나지만, 어떤 도구도 병합이 발생하는 모든 경우를 해결할 수 없다. 결국 병합에는 항상 위험이 뒤따르게 된다.
1. 개발자가 a() 메서드의 수정과 동시에 DBA 가 해당 테이블 스키마를 수정하기 위해 두 개발자가 하나의 클래스를 체크아웃 받은 후 변경사항을 적용.
2. 변경 사항이 충돌해 병합이 발생.

### 4. 위반에 대한 솔루션: 데이터 및 메서드 분리와 Facade Pattern
_데이터만 가지고 있는 클래스 공유_
- 각 클래스는 자신의 메서드에 필요한 요소만 코드만 포함하고 서로 존재를 모른다.
- 분리된 클래스를 인스턴스화 하고 추적 해야하는 단점이 발생.

<img src="/image/p.70%20SRP-Solution01.png" width="450" height="300" alt="p.70 SRP-Solution01"/>
<br><br>

_Facade Pattern_
- 간소화된 인터페이스를 제공한다.
- 객체를 생성하며, 클라이언트의 요청을 적절한 서브시스템의 메서드로 전달하는 역할.

<img src="/image/p.70%20SRP-Solution02.png" width="450" height="300" alt="p.70 SRP-Solution02"/>
<br><br>

_중요도에 따른 Facade Pattern_
- 기존 클래스와 직접적인 연관이 있는 메서드를 제외하고 개별 클래스로 분리 후, 기존 클래스를 퍼사드로 사용.

<img src="/image/p.70%20SRP-Solution03.png" width="450" height="300" alt="p.70 SRP-Solution03"/>

# OCP
_소프트웨어의 구성 요소는 확장에 열려 있어야 하지만, 변경에 닫혀 있어야 한다._
### 1. 확장과 변경
> 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.
> 소프트웨서 아키텍처를 공부하는 가장 근본적인 이유가 바로 이때문이다.   
> ...  
> 소프트웨어 설계를 공부하기 시작한 지 얼마 안된 사람들 대다수는 OCP 를 클래스와 모듈을 설계할 때 도움되는 원칙이라고 알고 있다. 하지만 아키텍처 컴포넌트 수준에서 OCP 를 고려할 때 훨씬 중요한 의미를 가진다.

_확장에 열려 있어야 한다._  

소프트웨어 구성 요소는 새로운 기능이나 요구 사항을 수용할 수 있도록, 기존의 코드를 그대로 두고 추가 요소나 기능을 넣을 수 있는 유연한 구조로 설계되어야 한다. 이를 통해 소프트웨어는 변경 없이 점진적으로 발전하고 새로운 요구사항을 충족할 수 있다.

추상화와 인터페이스의 개념을 활용하는 것이 중요하며, 새로운 기능은 기존 클래스나 모듈을 상속하거나 구현하는 방식으로 추가되어야 한다. 이러한 방식은 코드의 재사용성을 높이는 동시에 시스템을 확장할 때 발생하는 복잡성을 줄여준다.

확장이 용이한 구조는 장기적으로 유지보수 비용을 줄이고, 요구 사항 변화에 신속히 대응할 수 있는 시스템을 구축할 수 있다.

<br>

_변경에 닫혀 있어야 한다._  

기존의 코드를 수정하지 않고, 확장을 수행할 수 있어야 함을 의미한다.
검증된 기존 코드를 변경함으로써 발생할 수 있는 위험을 최소화함으로써, 확장을 통해 새로운 기능을 추가하면서도 기존의 코드를 안정적으로 유지해 새로운 오류나 문제 발생을 예방할 수 있다.

기존의 코드를 수정하지 않고, 확장을 수행할 수 있어야 함을 의미한다.  

검증된 기존 코드를 변경함으로써 발생할 수 있는 위험을 최소화하고, 이를 통해 새로운 기능을 추가하면서도 기존의 코드를 안정적으로 유지할 수 있다. 이러한 접근은 테스트 범위를 줄이고, 소프트웨어의 신뢰성을 높이는 데 기여한다.

시스템이 복잡해질수록 기존 코드의 변경이 다른 부분에 미치는 영향을 예측하기 어려워지므로, 새로운 기능 추가 시 기존 코드를 건드리지 않도록 하는 것은 필수적이다.
### 2. 의존성 체계화 와 컴포넌트의 계층구조
> 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙 SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙 DIP) 변경량을 최소화할 수 있다.

<img src="/image/p.76%20OCP%20-%20Solution.png" width="1539" height="800" alt="p.76 OCP-Solution"/>

> 여기서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다.   
> ...  
> 또 다른 점은 이중선은 화살표와 오직 한 방향으로 만 교차한다는 사실이다.  
> ...  
> 모든 컴포넌트 관계는 단방향으로 이루어 진다는 뜻이다.  
> ...  
> A 컴포넌트에서 발생한 변경으로부텨 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가  B 컴포넌트에 의존해야 한다. 
> 이 예제의 경우 Presenter 에서 발생한 변경으로 부터 Controller 를 보호하고자 한다. 그리고 View 에서 발생한 변경으로 부터 Presenter 를 보호하고자 한다. Interactor 는 다른 모든 것에서 발생한 변경으로 부터 보호 하고자 한다.   
> ...  
> Interactor 가 이처럼 특별한 위치를 차지해야만 하는가? 그 이유는 바로 Interactor 가 업무 규칙을 포함하기 때문이다.  
> ...  
> 보호의 계층구조가 수준(level) 이라는 개념을 바탕으로 어떻게 생성되는지 주목하자.  
> ...  
> OCP 는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. OCP 의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.  
> ...  
> 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

_단방향 의존성_

소프트웨어 구성 요소 간의 의존성은 단방향으로 이루어져야 한다. 그 이유는 컴포넌트 간 결합도를 낮추고 각 컴포넌트의 변경이 다른 컴포넌트에 미치는 영향을 최소화하기 위함이다.  

단방향 의존성은 **DIP** 와 밀접한 관련이 있으며, 고수준의 정책이나 규칙이 저수준의 구현 세부사항에 의존하지 않도록 설계한다.   
이렇게 설계 된다면, 상위 계층에서 하위 계층으로의 변경이 발생하더라도 상위 계층이 그 영향을 받지 않고 시스템의 유연성을 크게 증가시킨다.

<br>

_특정 수준 기반의 계층화_  

시스템 내에서 각 계층은 특정 수준을 기반으로 조직화되어 구성 요소들을 체계적으로 관리하고, 각 계층의 독립성을 보장한다. 이 독립성을 통해 변경 사항이 상위 계층에 미치는 영향을 줄여야 한다.  

계층화된 아키텍처는 계층 간의 의존성 방향을 명확히 함으로써, 변경 사항이 하위 계층에서만 발생하도록 제한하며, 상위 계층이 직접적인 의존성을 가지지 않도록 한다.  

높은 수준의 계층으로 갈수록 보호받는 수준이 높아지며, 이들 계층에는 핵심 비즈니스 로직이나 데이터 관리와 같은 중요한 기능이 포함된다.  
이를 통해 중요한 기능이 안정적으로 유지되며, 외부나 하위 계층의 변화가 있을 때도 재사용성과 유지보수성을 높일 수 있다.

# LSP
_자식 클래스는 부모 클래스를 대체할 수 있어야 한다._
### 1. 확장과 치환
> 1998년 바바라 리스코프(Barbara Liskov)는 하위 타입을 아래와 같이 정의 했다.
>> 여기에서 필요한 것은 다음과 같은 치환원칙이다.   
> S 타입의 객체 o1 각각에 대응하는 T 타입 객체  o2 가있고, T 타입을 이용해서 정의한 모든 프로그램 P 에서 o2 의 자리에 o1 을 치환하더라도 P 의 행위가 변하지 않는다면, S 는 T 의 하위 타입이다.

_치환_

자식 클래스는 부모 클래스의 행위를 정확히 모방할 수 있어야 하며, 이를 통해 자식 클래스의 인스턴스를 부모 클래스의 인스턴스로 대체해 사용할 때 기존 코드의 정확성을 해치지 않아야 한다. 이는 코드 재사용을 넘어, 기존 코드의 호환성을 유지하면서도 확장할 수 있는 설계를 의미한다.

부모 클래스의 계약을 준수하면서도 새로운 기능을 확장하는 것이 핵심이다. 자식 클래스가 부모 클래스의 메서드를 재정의하더라도, 그 동작이 부모 클래스의 기대된 동작 범위 내에서 일어나야 한다.

<br>

_상속의 확장_

상속을 통한 확장이 기능의 추가만을 의미하는 것이 아니라, 확장된 기능이 원래 클래스의 계약을 준수해야 한다는 것을 강조한다. 부모 클래스를 사용하는 기존 클라이언트 코드를 변경하지 않고 자식 클래스의 인스턴스를 사용할 수 있어야 함을 의미한다.

<br>

_전제 조건과 사후 조건_

**전제 조건** 과 **사후 조건** 을 고려해야 한다. 자식 클래스는 부모 클래스보다 더 강한 전제 조건을 요구해서는 안 되며, 더 약한 사후 조건을 반환해서는 안 된다. 즉, 자식 클래스는 부모 클래스와 동일하거나 더 약한 전제 조건, 더 강한 사후 조건을 보장해야 한다.

### 2. 상속 가이드와 위반 사례
> 객체 지향이 혁명처럼 등장한 초창기에는   
> ...  
>  LSP 는 상속을 사용하도록 가이드하는 방법 정도로 간주 되었다. 하지만 시간이 지나면서 LSP 는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해 왔다.  
>  여기서 말하는 인터페이스는  
>  ...  
>  자바스러운 언어라면 인터페이스 하나와 이를 구현하는 여러 개의 클래스로 구성된다. 루비라면 동일한 메서드 시그니처를 공유하는 여러 개의 클래스로 구성된다. 또는 동일한 REST 인터페이스에 응답하는 서비스 집단일 수도 있다.   
>  이상의 모든 상황은 물론 더 많은 경우에 LSP 를 적용할 수 있다. 잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환 가능성에 기대는 사용자들이 존재하기 때문이다.  
>  ...   
>  LSP 는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.
#### 2.1 LSP 를 준수하는 상속

<img src="/image/p.82%20LSP%20-%20Solution.png" width="450" height="300" alt="p.76 LSP-Solution01"/>

> 이들 두 하위 타입은 서로 다른 알고리즘을 이용해서 라이선스 비용을 계산한다.   
> ...  
> 이 설계는 LSP 를 준수하는데, Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지 전혀 의존하지 않기 때문이다. 이들 하위 타입은 모두 License 타입을 치환할 수 있다.
- 슈퍼클래스에 너무 많은 책임을 두지 않고, 필요에 따라 인터페이스를 분리하여 서브클래스가 구현해야 할 행동만을 정의한다.
#### 2.2 LSP 를 위반하는 상속 문제

<img src="/image/p.83%20LSP%20-%20Problem01.png" width="450" height="300" alt="p.76 LSP-Problem01"/>

> Square 는 Rectangle 의 하위 타입으로 적합하지 않은데, Rectangle 의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, Square 의 높이와 너비는 반드시 함께 변경되기 때문이다.  
> ...  
> (if문 등을 이용해서) Rectangle 이 실제로는 Square 인지를 검사하는 메서니즘을 User 에 추가하는 것이다. 하지만 이렇게 하면 User 의 행위가 사용하는 타입에 의존하게 되므로, 결국 서로 타입을 치환할 수 없게 된다.
- 서브클래스에서 슈퍼클래스의 메서드를 오버라이드하되, 예외를 추가로 발생시키거나 완전히 다른 동작을 구현하는 경우 서브클래스의 인스턴스로 슈퍼클래스의 인스턴스를 치환할 수 없다.

# ISP
_클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다._
### 1. 인터페이스 분리의 이유

<img src="/image/p.88,%2089%20ISP%20-%20Problem%20and%20Solution.png" width="800" height="350" alt="p.76 p.88, 89 ISP - Problem and Solution"/>

> op2와 op3를 전혀 사용하지 않음에도 User1의 소스 코드는 이 두 메서드에 의존하게 된다.    
> ...  
> 오퍼레이션을 인터페이스 단위로 분리하여 해결할 수 있다.

_필요한 기능만 제공하는 인터페이스 설계_

인터페이스는 각 클라이언트가 실제로 필요로 하는 기능만을 제공해야 한다. 이를 통해 시스템의 유연성을 높이고, 불필요한 의존성을 줄일 수 있다.  

특정 클라이언트가 필요로 하지 않는 메서드가 포함된 큰 인터페이스를 사용하게 되면, 해당 메서드가 변경될 때마다 불필요한 재컴파일이나 재배포가 발생할 수 있다.

작은 인터페이스는 각 클라이언트가 필요한 기능에만 집중할 수 있게 하여 코드 결합도를 낮추고 확장성을 높인다.

### 2. 소스 코드의 의존성
> 이처럼 소스코드에 포함된 선언문으로 인해 소스 코드 의존성이 발생하고, 이로인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.  
> 루비나 파이썬과 같은 동적 타입 언어에서는 소스 코드에 이러한 선언문이 존재하지 않는다. 대신 런타임 추론이 발생한다. 따라서 소스 코드 의존성이 아예 없으며, 결국 재컴파일과 재배포가 필요없다.   
> 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만즐 수 있는 이유는 바로 이 때문이다.  
> 이러한 사실로 인해 ISP 를 아키텍처가 아니라, 언어와 관련된 문제라고 결론내릴 여지가 있다.   
> ...  
> 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다. 소스 코드 의존성의 경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 때문이다.  
> ...  
> (옮긴이) 이 부분은 깊게 들어가면 상황이 좀 복잡해진다. 예를 들어 자바는 정적 타입 언어지만, (인터페이스를 분리하기 전인) op2 메서드의 시그니처가 변경되면 이를 사용하는 User2 만 재컴파일하면된다.  
> 시그니처는 그대로인 채 구현 코드만 변경됐다면 그마저도 다시 컴파일할 필요가 없다. 이렇게 동작하는 이유는 자바의 독특한 바인딩 방식에 있다.   
> 자바는 비-final, 비-private 인스턴스 변수에 대해서는 호출할 정확한 메서드를 런타임에 결정하는 늦은 바인딩(late binding)을 수행한다.   
> 컴파일 타임에는 호환되는 시그니처의 메서드가 타입 계층구조 어딘가에 존재하는지까지만 확인할 뿐이다. 따라서 ISP 는 언어 종류에 따라 영향받는 정도가 다르다.

_하나의 큰 인터페이스의 의존성 문제_

큰 인터페이스 하나가 클라이언트에게 필요하지 않은 메서드까지 포함하게 되면, 클라이언트는 자신이 사용하지 않는 메서드에 대한 의존성을 갖게 된다.

하나의 큰 인터페이스가 여러 클라이언트의 요구를 모두 수용하려 한다면, 클라이언트는 자신이 사용하지 않는 메서드에도 의존하게 된다. 이는 불필요한 결합도를 높이고, 유지보수를 어렵게 만든다.

해당 인터페이스의 일부 메서드가 변경되거나 제거되면, 해당 메서드를 사용하지 않는 클라이언트조차도 영향을 받게 되는데, **LSP 와도 관련이 있다.**   
자식 클래스가 부모 클래스를 대체할 수 있어야 한다는 원칙을 강조하지만, 부모 클래스에 너무 많은 책임이 있으면 자식 클래스는 불필요한 메서드를 구현해야 한다. 따라서 ISP 를 통해 인터페이스를 작은 단위로 분리하는 것이 필요하다.  

# DIP
_고 수준 모듈은 저수준 모듈에 의존하지 않아야 하며, 모든 의존성은 추상화에 의존해야 한다._
### 1. 추상에 의존하는 시스템
> '유연성이 극대화된 시스템' 이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.  
> 자바와 같은 정적 타입 언어에서 이말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다.   
> 구체적인 대상에는 절대로 의존해서는 안된다.  
> ...  
> 이 아이디어를 규칙으로 보기는 확실히 비현실적이다. 소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 의존하기 때문이다.  
> ...  
> 반면 String 클래스는 매우 안정적이다.  
> ...  
> DIP 를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.  
> ...   
> 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다.

_추상에 의존_

DIP 의 핵심은 구체적인 구현에 의존하지 않고 추상화된 인터페이스나 추상 클래스에 의존하는 시스템을 구축하는 것이다. 구체적인 클래스에 대한 의존성을 피함으로써, 시스템은 더 유연해지고 유지보수하기 쉬워진다.

**유연성이 극대화된 시스템** 이란 소스 코드 의존성이 추상에 의존하며, 구체적인 구현에 결박되지 않는 시스템으로, 자바와 같은 정적 타입 언어에서는클래스가 구체적인 클래스가 아닌, 인터페이스나 추상 클래스를 참조하는 형태.

클래스가 다른 클래스의 구체적인 구현에 의존하면, 그 구현이 변경될 때마다 의존하는 클래스도 변경되어야 하는 반면, 추상화된 인터페이스에 의존한다면, 구체적인 구현이 바뀌더라도 인터페이스만 동일하다면 다른 클래스에는 영향을 주지 않으므로 시스템의 유연성이 높아진다.

<br>

_안정적인 의존_

자주 변경되거나 불안정한 코드에 의존할 경우, 그 코드가 변경될 때마다 시스템 전체에 영향을 미치게 된다. 따라서 구체적인 구현은 변동성이 크기 때문에, 시스템의 안정성과 확장성을 해칠 수 있다.  
하지만, 안정적인 클래스나 운영체제와 같은 환경은 예외적으로 DIP 원칙을 완화할 수 있는데, 자바의 String 클래스는 매우 안정적이고 변동성이 거의 없기 때문에 이런 안정적인 구현체에 의존하는 것은 문제가 되지 않는다.
### 2. 안정된 추상화와 변동성
> 1. **변동성이 큰 구체 클래스를 참조하지 말라.**
> 	* 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제한다.
> 2. **변동성이 큰 구체 클래스로부터 파생하지 말라.**
> 	* 정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다. 따라서 상속은 아주 신중하게 사용해야 한다.
> 3. **구체 함수를 오버라이드 하지 말라.**
> 	* 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.
> 4. **구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.**
### 3. 추상 팩토리와 구체 컴포넌트

<img src="/image/p.94%20DIP%20-%20Factory.png" width="1025" height="645" alt="p.94 DIP - Factory"/> 

<br>
<br>

<details>
<summary>Code</summary>

```java
public interface Service {
    void execute();
}

public class ConcreteAImpl implements Service {
    @Override
    public void execute() {
        System.out.println("ConcreteAImpl: Executing Service...");
    }
}

public class ConcreteBImpl implements Service {
    @Override
    public void execute() {
        System.out.println("ConcreteBImpl: Executing Service...");
    }
}
```

```java
public interface ServiceFactory {
    Service makeSvc();
}

public class ServiceFactoryImpl implements ServiceFactory {
    private String serviceType;

    public ServiceFactoryImpl(String serviceType) {
        this.serviceType = serviceType;
    }

    @Override
    public Service makeSvc() {
        if (serviceType.equalsIgnoreCase("A")) {
            return new ConcreteAImpl(); 
        } else if (serviceType.equalsIgnoreCase("B")) {
            return new ConcreteBImpl();
        } else {
            throw new IllegalArgumentException("Unknown service type: " + serviceType);
        }
    }
}
```

```java
public class Application {
    private ServiceFactory serviceFactory;

    public Application(ServiceFactory serviceFactory) {
        this.serviceFactory = serviceFactory;
    }

    public void run() {
        Service service = serviceFactory.makeSvc();
        service.execute();
    }

    public static void main(String[] args) {
        ServiceFactory factoryA = new ServiceFactoryImpl("A");
        Application appA = new Application(factoryA);
        appA.run(); 

        ServiceFactory factoryB = new ServiceFactoryImpl("B");
        Application appB = new Application(factoryB);
        appB.run(); 
    }
}
```
</details>

> Application 은 Service 인터페이스를 통해 ConcreteImpl 을 사용하지만, Application 에서는 어떤 식으로든 ConcreteImpl 인스턴스를 생성해야 한다.   
> ConcreteImpl 에 대해 소스 코드 의존성을 만들지 않으면서 이 목적을 이루기 위해 Application 은 ServiceFactory 인터페이스의 makeSvc 메서드를 호출한다.   
> 이 메서드는 ServiceFactory 로 부터 파생된 ServiceFactoryImpl 에서 구현된다. 그리고 ServiceFactoryImpl 구현체가 ConcreteImpl 의 인스턴스를 생성한 후 Service 타입으로 반환된다.   
> ...  
> 곡선은 아키텍처 경계를 뜻한다.   
> ...  
> 곡선은 시스템을 두가지 컴포넌트로 분리한다. 하나는 추상 컴포넌트이며, 다른 하나는 구체 컴포넌트다.   
> 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다. 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.  
> 제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점에 주목하자. 다시 말해 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다.  
> ...  
> (옮긴이)ServiceFactoryImpl 구체 클래스가 ConcreteImpl 구체 클래스에 의존한다.  
> ...
> DIP 위배를 모드 없앨 수는 없다. 하지만 DIP 를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.
> ...  
> 곡선은 이후의 장에서는 아키텍처 경계가 될 것이다. 그리고 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 추후 이 규칙은 의존성 규칙이라 부를 것이다.

_추상 팩토리_

팩토리 인터페이스를 통해 서비스의 인스턴스 생성 메커니즘을 추상화.   
구체적인 클래스의 생성은 팩토리 구현 내부에서 이루어지며, 이 과정을 통해 시스템의 나머지 부분은 구체적인 클래스의 구현으로부터 독립적이게 되어 의존성을 팩토리 내부로 한정함으로써 구현 변경에 따른 영향을 최소화.

<br>

_구체 컴포넌트의 제어 흐름과 의존성 역전_

일반적인 설계에서는 저수준 모듈이 고수준 모듈에 의존하거나 제어를 전달받지만, DIP 를 적용하면 의존성의 방향이 역전되어 고수준 모듈이 추상화된 인터페이스에 의존하게 된다.

제어 흐름은 구체적인 구현체에서 시작하여, **추상화된 인터페이스** 로 향하는데, 고수준 모듈이 저수준 모듈의 구체적인 구현을 직접 호출하지 않고 인터페이스를 통해 제어 흐름이 이루어지도록 설계된다는 것을 의미한다.
이 과정에서 의존성은 제어 흐름의 반대 방향으로 움직이며, 고수준 모듈이 저수준 모듈에 의존하지 않고, 오히려 저수준 모듈이 추상화된 고수준 모듈에 의존하게 된다.

<br>

_DIP 위배의 허용과 관리_

모든 시스템에서 DIP 를 완벽하게 준수하는 것은 현실적으로 어려울 수 있는데, 특히 구체적인 컴포넌트 내부에서 DIP 를 위반하는 경우가 있다.
ServiceFactoryImpl 과 ConcreteImpl 같은 구체적인 클래스들 사이에는 여전히 의존성이 존재할 수 있다. 하지만 이러한 의존성은 시스템의 특정 구체적인 부분에 국한시키고, 고수준 모듈과 분리하여 관리하는 것이 중요하다.

<br>

_DIP 와 아키텍처 경계_

DIP 는 아키텍처의 경계를 설정하고, 이 경계를 넘어서 의존성이 흐르지 않도록 하는 중요한 역할을 한다.   
구체 컴포넌트와 추상 컴포넌트 사이의 경계를 명확히 나누고, 의존성은 항상 추상화된 엔티티 쪽으로만 향하게 하여 아키텍처의 안정성을 유지하고, 시스템을 더 유연하게 확장할 수 있도록 돕는다.

# Ref:
Clean Architecture (p.62~98) - Robert C. Martin